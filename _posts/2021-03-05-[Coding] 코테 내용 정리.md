---
subtitle: Spring
date: 2021-03-05 23:30:28 -0400
categories: CodingTest
tags: [CodingTest]
---

## 서론
이 포스팅은 개인적인 공부와 정리를 목적으로 다른 블로그의 글들을 짜집기한 내용들임을 밝힙니다.

## 1번

문제 : 전달받은 10진수의 값을 2진수로 변환한 뒤 비트값이 1인 비트가 몇 개 있는지 카운트하여 작은 10진수부터 오름차순으로 정렬(개수가 같다면 10진수의 값이 작은것 우선)

해설 : 
1. 전달 받은 수를 모두 객체에 담아 저장한다
1. 저장할때 10진수 고유의 값(decimal), 2진수의 값(binary), 2진수의 값에서 비트값이 1인것의 개수(원소의개수 : cardinality) , 이 3가지 필드값을 가진 객체로 생성한다.
1. 반복문을 돌며 객체를 생성한다.
1. 해당 객체를 타입으로 하는 리스트 객체 생성하여 이 리스트에 생성된 객체를 저장한다.
1. 객체를 모두 생서한 뒤 리스트를 정렬하기 위한 작업을 실시한다.
1. 객체의 정렬 메소드(comparable)를 오버라이딩 하여 필드값중 1의 개수 값(cardinality)을 기준으로 오름차순 정렬하게 한다.(개수가 같다면 10진수값으로 오름차순)
1. 정렬한다.
1. 정렬된 리스트를 차례대로 돌면서 객체의 10진수 값(decimal)을 새로운 리스트에 넣어 작성한 뒤 결과값으로 반환한다.


사용한 라이브러리 :
1. Integer.toBinary()
1. Arrays.sort()
: Arrays.sort()는 내부가 어떻게 구현되어 있을까,
    1. primitive type일 때 정리를 해 보았습니다. byte나 char, short인 경우, 집합의 크기가 작기 때문에
  기본적으로 길이가 꽤 큰 배열인 경우, count sort부터 해 본다. 
    1. 그렇지 않은 경우에, 먼저 dual pivot quick sort를 수행한다.(배열의 크기가 일정 이하이면, Insertion sort : 임계값 47 이하)

    1. Object인 경우에는 어떻게 동작할까요
        Object array를 정렬하는 경우에 따로 legacy한 merge를 쓰겠다는 설정을 하지 않으면 Tim sort를 시킨다.


1. Comparable 인터페이스 구현 후 compareTo() 메소드 오버라이딩
오버라이딩 함수에서 return 값이 양수이면 자리바꿈을 수행, 0이나 음수이면 자리바꿈을 하지 않는다.
비교결과 = 현재값 - 다음값 일경우 현재값 > 다음값이면 결과값이 양수이므로 return 비교결과를 하게 되면 자리바꿈을 수행하게 되어 더 큰 현재값이 작은 다음값과 스위칭되어 오름차순으로 정렬하게 된다.



## 2번. IP Address Validation
문제 : 전달받은 IP주소값을 검증 절차를 걸쳐 해당 주소값이 IPv4 형식의 주소값인지, IPv6 형식의 주소값인지, 둘다 아닌 에러값인지 구분하여 결과값을 리턴하도록 한다.

해설 : 
1. 문제에 주어진 IPv4형식에 대한 조건과 IPv6형식에 대한 조건을 구분하여 정리한다.
1. 각각 독립적으로 조건이 작성되어 있기 때문에 하나의 주소 타입씩 검증 메소드를 작성한다.
1. 각 주소값의 구분자가 '.' 인지 ':' 인지에 따라 IPv4검증메소드를 호출할지 IPv6검증 메소드를 호출할지 분기한다.
1. IPv4 검증 메소드 내용
    1. 주소값을 구분자로 Split 하여 각각의 문자열값을 리스트로 저장
    1. [전체형식검증] 4개의 그룹이 아닌경우 false (split으로 구분시 맨마지막에 있는 구분자는 뒤에 null로 개수에 영향을 주지 않으므로 별도로 맨마지막에 구분자 . 이 존재하는지 같이 체크)
    1. [전체형식검증] 1 byte에는 8진수값이 존재해야 하므로 0~255 사이의 값이 존재 해야 한다. 그 밖의 범위는 False
    1. [개별형식검증] 0255같이 정수값과 문자열값이 다를 수 있기 때문에 문자열의 길이가 0이거나 4이상인 것들은 False
    1. [개별형식검증] 최신버전에서는 8진수의 값과 10진수의 값에 혼동이 있을 수 있기 때문에 8이상의 값중 앞자리에 0이 붙는다면 이는 False.
1. IPv6 검증 메소드 내용
    1. [전체형식검증] '::' 구분자의 사용은 주소값 내에 1개만 존재 가능
    1. [전체형식검증] '::' 사용이 없다면 4bit짜리 8개의 그룹만 존재
    1. [개별형식검증] 4자리수 이상의 값이라면 False
    1. [개별형식검증] 16진수 값이 맞는지 검증, 아니라면 False
1. 결과값들을 리스트에 담아 반환

사용한 라이브러리 : 
- Character.digit(char c, int radix) : 한글자씩 루프돌면서 16진수인지 한글자씩 검사한다. -1 리턴시 16진수가 아닌 문자가 포함되어 있다는 의미

String.split()

개선점 : 
각각의 검증 메소드에서 불필요한 if else문을 많이 나열한것 같다.
내용상 일반 if문들로만 같은 레벨로 나열해도 무방한데 심층적으로 들어가는 구조로 중복 if문을 사용해버렸다.

<br>

## 3번 Binary Manipulation 2진수 조작
문제 : 전달받은 10진수 정수를 2진수로 변환한 뒤 주어진 조건에 따라 비트를 하나씩 변경하면서 최종적으로 0을 만드는데 변환되는 횟수를 구하여라

해설 :
(기존문제풀이)

1. 큐를 하나 생성하여 전환된 바이너리 값을 하나씩 삽입
1. 큐에서 하나씩 꺼내면서 각각의 룰로 하나씩 변환한 후 다시 큐에 삽입
1. 모든 경우의수를 수행한 뒤 횟수가 가장 적은것을 최종 값으로 제출
1. 하지만 경우의 수가 너무 많기 때문에 접근 방법 바꿈
1. 1번조건과 2번조건은 무조건 한번씩 번갈아가면서 수행하게 규칙이 되어 있음
1. 1번조건과 2번조건을 번갈아가며 수행했을때 연산 횟수를 구한 뒤 제출
1. 이때 1번조건을 먼저하는지 2번조건을 먼저하는지에 따라 결과값이 다를 수 있기 때문에 1번조건을 먼저 수행했을때의 결과와 2번조건을 먼저 수행했을때의 결과를 모두 구한 뒤 둘 중 최소값의 결과를 제출

* 1번조건
- 뒤에오는 비트값이 1이고 그 뒤에 있는 값이 모두 0이거나 존재 하지 않을때 현재위치의 비트를 전환
* 2번조건
- 맨 마지막 비트를 전환

사용 라이브러리
1. StringBuilder -> builder.setCharAt()
: String 은 불변객체이기 때문에 문자열의 수정이 있을경우 새로운 객체를 생성한다 따라서 메모리 할당과 속도가 상대적으로 느리기 때문에 문자열의 수정이 있을 경우 StringBuilder 객체를 사용한다. (빌더의 경우 문자열 복사를 하긴 하지만 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사, String은 두 문자열을 모두 읽어들이고 새로운 메모리에 복사하기 때문에 시간 소요)
Stringbuffer 는 동기화를 지원하기 때문에 멀티스레드 환경에서 유용
StringBuilder 는 동기화를 지원하지 않기 때문에 단일 스레드에서 권장 사용
1. HashSet
: Set는 순서를 보장하지 않기 때문에 순서와 중복에 신경쓰지 않고 데이터가 존재 하는지 않하는지만 체크할 때 유용
HashSet은 별도의 정렬 작업이 없어 성능이 가장 빠르다
1. Queue , LinkedList

## 4번 Is this a tree? 트리 검증하기

문제 : 주어진 문자열을 트리구조로 바꾼 뒤 에러 사항에 해당하지 않는 트리인지 검증하여 에러 케이스 조건에 부합한다면 해당 에러 번호를, 해당하지 않는다면 트리구조의 문자열 형태로 생성하여 반환한다.
- E1 : 부모노드에 연결된 자식노드가 3개이상일 경우
- E2 : 부모노드와 자식노드가 2개의 엣지로 연결될 경우
- E3 : 사이클이 형성된 경우
- E4 : 루트 노드가 2개 이상일 경우
- E5 : 그밖의 에러 경우

해설 : 
1. 전달받은 하나의 문자열을 파싱하여 노드맵에 삽입한다.
1. 각노드의 값(vertex)을 Key로 하여 visited 맵(해쉬맵)과 노드맵(해쉬맵) 각각에 넣어준다. -> 한 쌍에 2개의 노드 각각 생성 (중복은 제외한다)
1. 각각의 노드를 부모노드와 자식노드로 가져와 연결작업을 준비한다.
1. 에러검증
    1. 자식노드가 부모노드와 이미 연결이 있는지 확인(E1)
    1. 자식노드를 부모노드에 연결 -> 이미 양쪽이 꽉 차 있다면 에러반환 (E2) 
1. 에러검증(E4)
    1. 모든 노드를 하나씩 루프 돌면서 노드.parent를 찾는다. 찾을 때 하나씩 카운팅을 하면서 카운트가 2개 이상이면 에러 반환
1. 위에 단계에서 가져온 루트노드를 이용하여 사이클 여부를 검증한다.
    1. visited 해쉬맵을 이용하여 진입여부를 카운트를 이용하여 루트노드부터 자식노드를 하나씩 탐색하여 visit 값을 true로 세팅한다.
    1. 이미 방문한 적이 있다면 true 반환
    1. true시 에러 반환(E3)
1. 삽입된 에러들을 정렬하여 가장 낮은 숫자의 에러를 하나 대표적으로 꺼내 반환한다.
1. 에러가 존재하지 않았다면 트리포맷의 문자열로 변환한다.
    1. '('를 먼저 생성한 후 루트 노드 삽입
    1. 부모노드의 left 노드값이 존재하면 해당 노드를 파라미터로 넣고 재귀함수 호출


사용한 라이브러리 : 
없음