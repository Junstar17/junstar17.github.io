---
subtitle: JS 클로저
date: 2021-06-14 23:30:28 -0400
categories: Javascript
tags: [Javascript]
---

## 클로저란

1. MDN에서 정의한 클로저의 정의는 다음과 같다.

<br>

**“A closure is the combination of a function and the lexical environment within which that function was declared.”
클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.**

굉장히 딱딱한 용어들로 함축적인 의미를 담아 정의되어 있다.
여기서 포인트는 '렉시컬 환경' 의 의미를 파악하는것으로 보여진다.

다음 예제를 통해 어떤 특징이 있는지 확인해 보자.

예제)       
```
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  innerFunc();
}

outerFunc(); // 10
```

위의 함수 구조에서는 중첩 함수구문으로 되어 있다.
외부의 outerFunc이 존재하고 그 내부에 innerFunc이 선언되어 있다.
이때 특징을 보면 내부 함수에서 외부함수의 변수에 접근할 수 있다는 점이 있다.

<br>

**렉시컬 스코핑(Lexical scoping)이란 스코프를 정의할 때 함수를 호출하는 시점에 따른게 아니라 함수를 어디에서 선언하였는지에 따라 정해진다. 위 예제의 함수 innerFunc는 함수 outerFunc의 내부에서 선언되었기 때문에 함수 innerFunc의 상위 스코프는 함수 outerFunc이다. 함수 innerFunc가 전역에 선언되었다면 함수 innerFunc의 상위 스코프는 전역 스코프가 된다.**


따라서 위의 innerFunc의 렉시컬 스코프는 `전역, outerFunc, 자신` 이렇게 3가지 영역의 접근이 가능하게 되는 것이다.

위의 예제를 조금 변형한 아래의 예제를 살펴봄으로써 클로저에 대해 알아보도록 하자

<br>


```
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  return innerFunc;
}

/**
 *  함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다.
 *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다.
 */
var inner = outerFunc();
inner(); // 10
```
<br>

위의 예제에서는 outerFunc내에서 innerFunc을 호출함으로써 콜스택에 유지된 채로 innerFunc을 호출하는 것이 아니라 outerFunc()이 호출됨과 동시에 내부의 innerFunc을 반환하고 자신의 기능은 소멸되게 되는 구조로 바뀌었다. 따라서 변수 `x`의 값도 메모리에서 제거되게 된다. <br>
하지만 예상과 달리 inner() 함수를 호출하였을때 innerFunc()의 내부에서 호출하는 `x` 의 존재가 여전히 살아 있어 `10` 이라는 값을 출력하게 된다. 
<br>
어떻게 소멸된 `x` 의 값이 여전히 살아 있어 출력을 할 수 있는 것일까?

이것이 바로 클로저의 특징이다.

**이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다.**

이제 다시 MDN의 클로저 정의를 생각해보면 이해가 될 것이다.

`함수`와 `그 함수` 가 선언 되었을 때 `렉시컬 환경`
-> 여기서 함수는 'innerFunc'이고 `렉시컬 환경`은 innerFunc이 호출되었을때의 스코프, 즉 전역,outerFunc,자기자신의 영역을 나타낸다.
따라서, 클로저는 반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하여, 자신이 나중에 환경 밖에서(스코프 밖)에서 호출된다 할지라도 그 환경(스코프)에 접근할 수 있는 함수를 의미하는 것이다.

<br>
한 문장으로 정의하면, <br>

**클로저는 자신이 생성될 때의 환경을 기억한는 함수이다**

그렇다면 `x`는 왜 소멸되지 않고 남아있는것인가? 어떠한 형태로 남아 있는 것인가?

<Br>

클로저에서 참조하고 있는 outerFunc의 변수 `x` 는 `자유변수` 라고 부른다. 클로저라는 용어의 의미가 여기서 자유변수에 함수가 닫혀있다(엮여있다) 라는 의미로서 클로저로 불리운다.

내부함수가 유효한 상태에서 외부함수의 활성객체(변수,함수선언) 를 참조하고 있다면, 외부함수의 실행 컨텍스트가 반환된다 하더라도 내부함수가 스코프 체인을 통해 참조할 수 있게된다. 즉, 외부함수 내의 변수는 내부함수가 참조하는게 있다면 계속 유지되고 이는 얕은 복사가 아닌 깊은 복사로 실제 변수에 접근할 수 있게 된다.


<br>
<br>

다음 예제들을 통해 클로저의 활용성을 알아보도록 하자.

## 1. 상태 유지

클로저가 가장 유용하게 사용되는 상황은 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것이다.

```html
<!DOCTYPE html>
<html>
<body>
  <button class="toggle">toggle</button>
  <div class="box" style="width: 100px; height: 100px; background: red;"></div>

  <script>
    var box = document.querySelector('.box');
    var toggleBtn = document.querySelector('.toggle');

    var toggle = (function () {
      var isShow = false;

      // ① 클로저를 반환
      return function () {
        box.style.display = isShow ? 'block' : 'none';
        // ③ 상태 변경
        isShow = !isShow;
      };
    })();

    // ② 이벤트 프로퍼티에 클로저를 할당
    toggleBtn.onclick = toggle;
  </script>
</body>
</html>
```

위의 에제의 특징은 `isShow` 변수를 toggle 내부함수에서 계속 유지하고 있으며 상태를 변경해 나갈 수 있다는 부분이다. 이때 `isShow`의 위치가 중요하다.
내부함수내에 위치시키게 되면 `isShow`는 의미가 없어진다. 왜냐하면 호출될 때마다 초기화가 되기 때문에 상태값이 늘 똑같을 수 밖에 없기 때문이다. 그렇다면 이 변수는 호출문 밖에서 생성되어야 한다.
<br>
일반적인 클래스 구문에서는 클래스 멤버 변수에 선언하고 함수에서 이 멤버변수를 참조하는 식의 방식이 있고, 이 객체 내에서만 사용되는 변수가 아니라면 전역에 선언하여 모든 서로 다른 클래스의 객체들이 참조하여 상태를 참조 할 수 있는 방식이 있다.
<br>
여기서는 전자의 가까운 상황으로 활용된다. 자바스크립트에서 클로저라는 기능이 없다면 상태를 유지하기 위해 전역변수를 사용할 수 밖에 없는데, 전역변수는 언제든지 누구나 접근,수정이 가능하기 때문에 큰 리스크와 부작용을 유발할 수 있어 사용에 자제를 해야하는 부분이다.
따라서 이러한 상황에서 클로저함수를 사용하여 `상태를 유지하고, 접근을 제한 하는 특성을 부여한다.`


## 2. 정보 은닉

위의 예제를 통해 잠깐 언급했지만, 접근을 제한한다는 특징이 있다. 따라서 클래스의 `private` 와 같은 접근제한자의 특징을 부여할 수 있다.

```Javascript
function Counter() {
  // 카운트를 유지하기 위한 자유 변수
  var counter = 0;

  // 클로저
  this.increase = function () {
    return ++counter;
  };

  // 클로저
  this.decrease = function () {
    return --counter;
  };
}

const counter = new Counter();

console.log(counter.increase()); // 1
console.log(counter.decrease()); // 0
```

위의 예제에서는 생성자 함수 Counter는 2개의 함수 (increase, decrease)를 객체의 프로퍼티의 바인딩 하였고, 변수 counter는 바인딩하지 않았다. 변수 counter가 바인딩 되었다면 counter.counter을 통해 접근이 가능한 `public` 변수였겠지만, 그렇지 않기 때문에 접근할 수 없는 `private` 변수로서의 정보은닉의 특성을 지니게 된다.


<br>
<hr>

**Reference** <br>
https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures <br>
https://poiemaweb.com/js-closure
